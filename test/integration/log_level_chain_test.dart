// ignore_for_file: avoid_print

import 'dart:io';
import 'package:flutter_test/flutter_test.dart';
import '../test_helpers/test_sonix_instance.dart';
import 'package:sonix/src/native/native_audio_bindings.dart';
import '../ffmpeg/ffmpeg_setup_helper.dart';
import '../../tool/test_data_generator.dart';

/// Comprehensive integration test for log level functionality across all data sources
///
/// This test verifies that log level configuration works correctly with:
/// - Synthetic test data generated by TestDataGenerator
/// - Verified test files in test/assets/
/// - User-provided real audio files in test/assets/real_audio/
///
/// Tests the complete chain: SonixConfig ‚Üí Sonix ‚Üí NativeAudioBindings ‚Üí native C code
void main() {
  setUpAll(() async {
    // Setup FFMPEG binaries for testing - required for native binding tests
    await FFMPEGSetupHelper.setupFFMPEGForTesting();

    // Generate essential test data for comprehensive testing
    await TestDataGenerator.generateEssentialTestData();
  });

  group('Native Binding Chain Verification', () {
    test('verify NativeAudioBindings.setLogLevel can be called directly', () async {
      print('=== Testing Direct Native Binding Calls ===');

      // Initialize native bindings first
      try {
        NativeAudioBindings.initialize();
        print('‚úÖ NativeAudioBindings initialized successfully');
      } catch (e) {
        print('‚ùå Failed to initialize NativeAudioBindings: $e');
        fail('Cannot test log levels without native bindings: $e');
      }

      // Test calling setLogLevel directly with different values
      final testLevels = [-1, 0, 1, 2, 3, 4, 5, 6];

      for (final level in testLevels) {
        try {
          print('Setting log level to $level...');
          NativeAudioBindings.setLogLevel(level);
          print('‚úÖ setLogLevel($level) called successfully');
        } catch (e) {
          print('‚ùå setLogLevel($level) failed: $e');
          fail('Direct native call failed for level $level: $e');
        }
      }

      print('‚úÖ All direct setLogLevel calls succeeded');
    });

    test('verify Sonix constructor calls _configureLogLevel', () async {
      print('\n=== Testing Sonix Constructor Log Level Configuration ===');

      // Test that each SonixConfig actually triggers the log level setting
      final testConfigs = [
        (TestSonixConfig(logLevel: -1), 'QUIET'),
        (TestSonixConfig(logLevel: 2), 'ERROR'),
        (TestSonixConfig(logLevel: 3), 'WARNING'),
        (TestSonixConfig(logLevel: 6), 'DEBUG'),
      ];

      for (final (config, levelName) in testConfigs) {
        print('Testing $levelName level (${config.logLevel})...');

        try {
          // Create Sonix instance - this should call _configureLogLevel in constructor
          final sonix = TestSonixInstance(config);

          // Verify the config was stored correctly
          expect(sonix.config.logLevel, equals(config.logLevel), reason: 'Config log level should match');

          print('‚úÖ TestSonixInstance created with logLevel: ${sonix.config.logLevel}');

          // Initialize to ensure no errors
          await sonix.initialize();
          print('‚úÖ Instance initialized successfully');

          await sonix.dispose();
          print('‚úÖ Instance disposed successfully');
        } catch (e) {
          print('‚ùå Failed for $levelName level: $e');
          fail('Sonix instance creation/initialization failed for $levelName: $e');
        }
      }

      print('‚úÖ All Sonix constructor configurations succeeded');
    });
  });

  group('Log Level Integration with Synthetic Test Data', () {
    test('ERROR level should suppress warnings for generated MP3 files', () async {
      print('\n=== Testing Log Level with Generated MP3 Files ===');

      // Get generated MP3 test files
      final mp3Files = await _getTestFilesForFormat('mp3');
      if (mp3Files.isEmpty) {
        print('No generated MP3 test files found, skipping synthetic data test');
        return;
      }

      for (final mp3File in mp3Files.take(2)) {
        // Test a few files
        print('Testing ERROR level with generated file: $mp3File');

        try {
          final sonix = TestSonixInstance(const TestSonixConfig(logLevel: 2)); // ERROR level
          await sonix.initialize();

          final waveform = await sonix.generateWaveform(
            mp3File,
            resolution: 50, // Quick test
          );

          expect(waveform, isNotNull);
          expect(waveform.amplitudes, isNotEmpty);
          print('‚úÖ Processed generated MP3 with ERROR level');

          await sonix.dispose();
        } catch (e) {
          print('‚ùå Failed to process generated MP3 $mp3File: $e');
        }
      }
    });

    test('WARNING level should show more output for generated files', () async {
      print('\n=== Testing WARNING Level with Generated Audio Files ===');

      // Test with multiple formats
      for (final format in ['mp3', 'wav']) {
        final files = await _getTestFilesForFormat(format);
        if (files.isEmpty) continue;

        final testFile = files.first;
        print('Testing WARNING level with generated $format file: $testFile');

        try {
          final sonix = TestSonixInstance(const TestSonixConfig(logLevel: 3)); // WARNING level
          await sonix.initialize();

          final waveform = await sonix.generateWaveform(testFile, resolution: 25);

          expect(waveform, isNotNull);
          print('‚úÖ Processed generated $format file with WARNING level');

          await sonix.dispose();
        } catch (e) {
          print('‚ùå Failed to process generated $format file: $e');
        }
      }
    });
  });

  group('Log Level Integration with Verified Test Files', () {
    test('should handle verified test assets with different log levels', () async {
      print('\n=== Testing Log Level with Verified Test Assets ===');

      // Check for verified test files in test/assets/
      final verifiedFiles = await _getVerifiedTestFiles();
      if (verifiedFiles.isEmpty) {
        print('No verified test files found in test/assets/, skipping verification test');
        return;
      }

      for (final testFile in verifiedFiles.take(3)) {
        // Test a few verified files
        print('Testing with verified file: $testFile');

        // Test with ERROR level (should suppress warnings)
        try {
          final sonix = TestSonixInstance(const TestSonixConfig(logLevel: 2));
          await sonix.initialize();

          final waveform = await sonix.generateWaveform(testFile, resolution: 30);

          expect(waveform, isNotNull);
          expect(waveform.amplitudes, isNotEmpty);
          print('‚úÖ Processed verified file with ERROR level');

          await sonix.dispose();
        } catch (e) {
          print('‚ùå Failed to process verified file $testFile: $e');
        }
      }
    });
  });

  group('Log Level Integration with User-Provided Real Files', () {
    test('should handle real audio files with proper log suppression', () async {
      print('\n=== Testing Log Level with User-Provided Real Audio Files ===');

      final realAudioDir = Directory('test/assets/real_audio');
      if (!realAudioDir.existsSync()) {
        print('test/assets/real_audio directory does not exist');
        print('Users can create this directory and add problematic MP3 files for testing');
        return;
      }

      final realFiles = realAudioDir.listSync().whereType<File>().where((f) => _isAudioFile(f.path)).toList();

      if (realFiles.isEmpty) {
        print('No real audio files found in test/assets/real_audio/');
        print('Users can add MP3 files like "Eminem - Lose Yourself (djGraff ext mix).mp3" for testing');
        return;
      }

      print('Found ${realFiles.length} real audio files for testing');

      for (final realFile in realFiles.take(3)) {
        // Test a few real files
        final fileName = realFile.path.split(Platform.pathSeparator).last;
        print('Testing log levels with real file: $fileName');

        // Test ERROR level (should suppress MP3 warnings like "invalid new backstep")
        try {
          print('  Testing ERROR level (should suppress warnings)...');
          final sonixError = TestSonixInstance(const TestSonixConfig(logLevel: 2));
          await sonixError.initialize();

          final waveformError = await sonixError.generateWaveform(realFile.path, resolution: 50);

          expect(waveformError, isNotNull);
          expect(waveformError.amplitudes, isNotEmpty);
          expect(waveformError.duration, greaterThan(Duration.zero));

          print('  ‚úÖ ERROR level processing successful');
          print('     Duration: ${waveformError.duration}');
          print('     Sample Rate: ${waveformError.sampleRate}Hz');
          print('     Amplitudes: ${waveformError.amplitudes.length} points');

          await sonixError.dispose();

          // Test WARNING level (should show more output)
          print('  Testing WARNING level (should show more output)...');
          final sonixWarning = TestSonixInstance(const TestSonixConfig(logLevel: 3));
          await sonixWarning.initialize();

          final waveformWarning = await sonixWarning.generateWaveform(realFile.path, resolution: 50);

          expect(waveformWarning, isNotNull);
          expect(waveformWarning.amplitudes, isNotEmpty);

          print('  ‚úÖ WARNING level processing successful');
          print('     (Any MP3 warnings should be visible in console output)');

          await sonixWarning.dispose();
        } catch (e) {
          print('  ‚ùå Failed to process real file $fileName: $e');
          // Don't fail the test for individual problematic files
        }
      }
    });

    test('should compare log output between QUIET and WARNING levels', () async {
      print('\n=== Comparing QUIET vs WARNING Log Output ===');

      final realAudioDir = Directory('test/assets/real_audio');
      if (!realAudioDir.existsSync()) {
        print('No real audio directory - this test requires user-provided files');
        return;
      }

      final mp3Files = realAudioDir
          .listSync()
          .whereType<File>()
          .where((f) => f.path.toLowerCase().endsWith('.mp3'))
          .take(1) // Test with one MP3 file
          .toList();

      if (mp3Files.isEmpty) {
        print('No MP3 files found for log comparison test');
        return;
      }

      final testFile = mp3Files.first;
      final fileName = testFile.path.split(Platform.pathSeparator).last;
      print('Comparing log levels with: $fileName');

      try {
        // Test QUIET level (should produce minimal output)
        print('  Testing QUIET level...');
        final sonixQuiet = TestSonixInstance(const TestSonixConfig(logLevel: -1));
        await sonixQuiet.initialize();

        final waveformQuiet = await sonixQuiet.generateWaveform(testFile.path, resolution: 30);

        expect(waveformQuiet, isNotNull);
        print('  ‚úÖ QUIET level: Should see minimal console output');

        await sonixQuiet.dispose();

        // Test WARNING level (should show MP3 warnings if file is problematic)
        print('  Testing WARNING level...');
        final sonixWarning = TestSonixInstance(const TestSonixConfig(logLevel: 3));
        await sonixWarning.initialize();

        final waveformWarning = await sonixWarning.generateWaveform(testFile.path, resolution: 30);

        expect(waveformWarning, isNotNull);
        print('  ‚úÖ WARNING level: Should see more console output (including any MP3 warnings)');

        await sonixWarning.dispose();

        print('  üìä Log Level Comparison Complete');
        print('     Compare the console output above to verify log suppression is working');
      } catch (e) {
        print('  ‚ùå Log comparison test failed: $e');
      }
    });
  });

  group('Dynamic Log Level Changes', () {
    test('verify log level changes take effect immediately', () async {
      print('\n=== Testing Dynamic Log Level Changes ===');

      try {
        // Start with one level
        print('Setting initial log level to WARNING (3)...');
        NativeAudioBindings.setLogLevel(3);

        // Change to another level
        print('Changing log level to ERROR (2)...');
        NativeAudioBindings.setLogLevel(2);

        // Change to QUIET
        print('Changing log level to QUIET (-1)...');
        NativeAudioBindings.setLogLevel(-1);

        // Change back to WARNING
        print('Changing log level back to WARNING (3)...');
        NativeAudioBindings.setLogLevel(3);

        print('‚úÖ Dynamic log level changes completed successfully');
        print('   Each call should take immediate effect for subsequent FFmpeg operations');
      } catch (e) {
        print('‚ùå Dynamic log level change failed: $e');
        fail('Dynamic log level changes are not working: $e');
      }
    });
  });
}

/// Helper function to get test files for a specific format
Future<List<String>> _getTestFilesForFormat(String format) async {
  final assetsDir = Directory(TestDataGenerator.assetsPath);
  if (!await assetsDir.exists()) {
    return [];
  }

  final files = await assetsDir
      .list()
      .where((entity) => entity is File)
      .cast<File>()
      .where((file) => file.path.toLowerCase().endsWith('.$format'))
      .map((file) => file.path)
      .toList();

  return files;
}

/// Helper function to get verified test files from test/assets/
Future<List<String>> _getVerifiedTestFiles() async {
  final assetsDir = Directory('test/assets');
  if (!await assetsDir.exists()) {
    return [];
  }

  final files = await assetsDir
      .list(recursive: false)
      .where((entity) => entity is File)
      .cast<File>()
      .where((file) => _isAudioFile(file.path))
      .map((file) => file.path)
      .toList();

  return files;
}

/// Helper function to determine if a file is an audio file
bool _isAudioFile(String path) {
  final extension = path.split('.').last.toLowerCase();
  const audioExtensions = ['mp3', 'wav', 'flac', 'ogg', 'opus', 'aac', 'm4a', 'wma', 'aiff'];
  return audioExtensions.contains(extension);
}
