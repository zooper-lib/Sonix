/// Tests for chunked decoder functionality using real audio test data.
///
/// This test suite validates the chunked decoder API with actual audio files
/// generated by the test data generator. It tests:
/// - Format detection for various audio formats
/// - Chunked decoder initialization and cleanup
/// - File chunk processing
/// - Error handling for corrupted files
/// - Edge cases and boundary conditions
///
/// The tests are designed to be robust and handle cases where:
/// - Native library may not be available
/// - Test files may not exist
/// - Format detection may return unexpected results
/// - Decoder initialization may fail (which can be expected)

import 'dart:ffi' as ffi;
import 'dart:io';
import 'package:ffi/ffi.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:sonix/src/native/sonix_bindings.dart';
import '../test_helpers/test_data_loader.dart';

/// Helper function to check if native library is available
bool _isNativeLibraryAvailable() {
  try {
    // Try to call a simple native function to test availability
    final testPtr = malloc<ffi.Uint8>(4);
    try {
      SonixNativeBindings.detectFormat(testPtr, 0);
      return true;
    } finally {
      malloc.free(testPtr);
    }
  } catch (e) {
    return false;
  }
}

void main() {
  group('Chunked Decoder Real Data Tests', () {
    late bool nativeLibAvailable;

    setUpAll(() async {
      // Check if native library is available
      nativeLibAvailable = _isNativeLibraryAvailable();

      if (!nativeLibAvailable) {
        // ignore: avoid_print
        print('Native library not available - some tests will be skipped');
        return;
      }

      // Ensure test data is available
      final hasSmallFile = await TestDataLoader.assetExists('mono_44100.wav');
      if (!hasSmallFile) {
        fail('Test data not found. Please run: dart run tools/test_data_generator.dart --essential');
      }
    });

    test('should have required test files available', () async {
      final requiredFiles = ['mono_44100.wav', 'stereo_44100.wav'];
      final optionalFiles = ['short_duration.mp3', 'sample_audio.flac', 'sample_audio.ogg', 'invalid_format.xyz', 'empty_file.mp3'];

      // Check required files
      for (final file in requiredFiles) {
        final exists = await TestDataLoader.assetExists(file);
        expect(exists, isTrue, reason: 'Required test file $file not found. Run: dart run tools/test_data_generator.dart --essential');
      }

      // Report on optional files
      for (final file in optionalFiles) {
        final exists = await TestDataLoader.assetExists(file);
        if (!exists) {
          // ignore: avoid_print
          print('Optional test file $file not found - some tests may be skipped');
        }
      }

      // List available files for debugging
      final availableFiles = await TestDataLoader.getAvailableAudioFiles();
      expect(availableFiles.length, greaterThan(0), reason: 'Should have at least some test files available');
    });

    test('should handle real WAV file processing', () async {
      if (!nativeLibAvailable) {
        // ignore: avoid_print
        print('Skipping WAV processing test - native library not available');
        return;
      }

      final wavPath = TestDataLoader.getAssetPath('mono_44100.wav');
      final wavFile = File(wavPath);

      expect(await wavFile.exists(), isTrue, reason: 'WAV test file should exist at $wavPath');

      // Test format detection
      final fileBytes = await wavFile.readAsBytes();
      final dataPtr = malloc<ffi.Uint8>(fileBytes.length);
      final nativeData = dataPtr.asTypedList(fileBytes.length);
      nativeData.setAll(0, fileBytes);

      try {
        final detectedFormat = SonixNativeBindings.detectFormat(dataPtr, fileBytes.length);
        expect(detectedFormat, anyOf([SONIX_FORMAT_WAV, SONIX_FORMAT_UNKNOWN]));

        // Test chunked decoder initialization - use detected format or fallback to WAV
        final formatToUse = detectedFormat == SONIX_FORMAT_UNKNOWN ? SONIX_FORMAT_WAV : detectedFormat;
        final filePathPtr = wavFile.path.toNativeUtf8();
        try {
          final decoder = SonixNativeBindings.initChunkedDecoder(formatToUse, filePathPtr.cast<ffi.Char>());

          if (decoder.address != 0) {
            // Test chunk processing with the file data
            final chunkPtr = malloc<SonixFileChunk>();
            final chunk = chunkPtr.ref;
            chunk.data = dataPtr;
            chunk.size = fileBytes.length;
            chunk.position = 0;
            chunk.is_last = 1;

            try {
              final result = SonixNativeBindings.processFileChunk(decoder, chunkPtr);

              if (result.address != 0) {
                final resultData = result.ref;
                // Accept various valid responses for real files
                expect(resultData.error_code, anyOf([SONIX_OK, SONIX_ERROR_INVALID_DATA, SONIX_ERROR_DECODE_FAILED]));

                // Clean up result
                SonixNativeBindings.freeChunkResult(result);
              }
            } finally {
              malloc.free(chunkPtr);
            }

            // Test seeking
            final seekResult = SonixNativeBindings.seekToTime(decoder, 0);
            expect(seekResult, anyOf([SONIX_OK, SONIX_ERROR_INVALID_DATA]));

            // Cleanup decoder
            SonixNativeBindings.cleanupChunkedDecoder(decoder);
          } else {
            // Decoder initialization failed - this might be expected
            // ignore: avoid_print
            print('Decoder initialization failed for WAV file - this may be expected');
          }
        } finally {
          malloc.free(filePathPtr);
        }
      } finally {
        malloc.free(dataPtr);
      }
    });

    test('should handle real stereo WAV file processing', () async {
      if (!nativeLibAvailable) {
        // ignore: avoid_print
        print('Skipping stereo WAV processing test - native library not available');
        return;
      }

      final wavPath = TestDataLoader.getAssetPath('stereo_44100.wav');
      final wavFile = File(wavPath);

      expect(await wavFile.exists(), isTrue, reason: 'Stereo WAV test file should exist at $wavPath');

      final fileBytes = await wavFile.readAsBytes();
      final dataPtr = malloc<ffi.Uint8>(fileBytes.length);
      final nativeData = dataPtr.asTypedList(fileBytes.length);
      nativeData.setAll(0, fileBytes);

      try {
        final detectedFormat = SonixNativeBindings.detectFormat(dataPtr, fileBytes.length);
        expect(detectedFormat, anyOf([SONIX_FORMAT_WAV, SONIX_FORMAT_UNKNOWN]));

        // Test chunked decoder initialization - use detected format or fallback to WAV
        final formatToUse = detectedFormat == SONIX_FORMAT_UNKNOWN ? SONIX_FORMAT_WAV : detectedFormat;
        final filePathPtr = wavFile.path.toNativeUtf8();
        try {
          final decoder = SonixNativeBindings.initChunkedDecoder(formatToUse, filePathPtr.cast<ffi.Char>());

          if (decoder.address != 0) {
            // Test chunk processing
            final chunkPtr = malloc<SonixFileChunk>();
            final chunk = chunkPtr.ref;
            chunk.data = dataPtr;
            chunk.size = fileBytes.length;
            chunk.position = 0;
            chunk.is_last = 1;

            try {
              final result = SonixNativeBindings.processFileChunk(decoder, chunkPtr);

              if (result.address != 0) {
                final resultData = result.ref;
                // Accept both success and various error conditions for real files
                expect(resultData.error_code, anyOf([SONIX_OK, SONIX_ERROR_INVALID_DATA, SONIX_ERROR_DECODE_FAILED]));

                // Clean up result
                SonixNativeBindings.freeChunkResult(result);
              }
            } finally {
              malloc.free(chunkPtr);
            }

            // Cleanup decoder
            SonixNativeBindings.cleanupChunkedDecoder(decoder);
          } else {
            // ignore: avoid_print
            print('Stereo WAV decoder initialization failed - this may be expected');
          }
        } finally {
          malloc.free(filePathPtr);
        }
      } finally {
        malloc.free(dataPtr);
      }
    });

    test('should handle real MP3 file processing', () async {
      if (!nativeLibAvailable) {
        // ignore: avoid_print
        print('Skipping MP3 processing test - native library not available');
        return;
      }

      final mp3Path = TestDataLoader.getAssetPath('short_duration.mp3');
      final mp3File = File(mp3Path);

      if (!await mp3File.exists()) {
        // Skip test if MP3 file doesn't exist
        // ignore: avoid_print
        print('Skipping MP3 test - file not found: $mp3Path');
        return;
      }

      final fileBytes = await mp3File.readAsBytes();
      final dataPtr = malloc<ffi.Uint8>(fileBytes.length);
      final nativeData = dataPtr.asTypedList(fileBytes.length);
      nativeData.setAll(0, fileBytes);

      try {
        final detectedFormat = SonixNativeBindings.detectFormat(dataPtr, fileBytes.length);
        expect(detectedFormat, anyOf([SONIX_FORMAT_MP3, SONIX_FORMAT_UNKNOWN]));

        // Test chunked decoder initialization - use detected format or fallback to MP3
        final formatToUse = detectedFormat == SONIX_FORMAT_UNKNOWN ? SONIX_FORMAT_MP3 : detectedFormat;
        final filePathPtr = mp3File.path.toNativeUtf8();
        try {
          final decoder = SonixNativeBindings.initChunkedDecoder(formatToUse, filePathPtr.cast<ffi.Char>());

          if (decoder.address != 0) {
            // Test seeking
            final seekResult = SonixNativeBindings.seekToTime(decoder, 0);
            expect(seekResult, anyOf([SONIX_OK, SONIX_ERROR_INVALID_DATA]));

            // Cleanup decoder
            SonixNativeBindings.cleanupChunkedDecoder(decoder);
          } else {
            // ignore: avoid_print
            print('MP3 decoder initialization failed - this may be expected');
          }
        } finally {
          malloc.free(filePathPtr);
        }
      } finally {
        malloc.free(dataPtr);
      }
    });

    test('should handle real FLAC file processing', () async {
      if (!nativeLibAvailable) {
        // ignore: avoid_print
        print('Skipping FLAC processing test - native library not available');
        return;
      }

      final flacPath = TestDataLoader.getAssetPath('sample_audio.flac');
      final flacFile = File(flacPath);

      if (!await flacFile.exists()) {
        // Skip test if FLAC file doesn't exist
        // ignore: avoid_print
        print('Skipping FLAC test - file not found: $flacPath');
        return;
      }

      final fileBytes = await flacFile.readAsBytes();
      final dataPtr = malloc<ffi.Uint8>(fileBytes.length);
      final nativeData = dataPtr.asTypedList(fileBytes.length);
      nativeData.setAll(0, fileBytes);

      try {
        final detectedFormat = SonixNativeBindings.detectFormat(dataPtr, fileBytes.length);
        expect(detectedFormat, anyOf([SONIX_FORMAT_FLAC, SONIX_FORMAT_UNKNOWN]));

        // Test chunked decoder initialization - use detected format or fallback to FLAC
        final formatToUse = detectedFormat == SONIX_FORMAT_UNKNOWN ? SONIX_FORMAT_FLAC : detectedFormat;
        final filePathPtr = flacFile.path.toNativeUtf8();
        try {
          final decoder = SonixNativeBindings.initChunkedDecoder(formatToUse, filePathPtr.cast<ffi.Char>());

          if (decoder.address != 0) {
            // Test seeking
            final seekResult = SonixNativeBindings.seekToTime(decoder, 0);
            expect(seekResult, anyOf([SONIX_OK, SONIX_ERROR_INVALID_DATA]));

            // Cleanup decoder
            SonixNativeBindings.cleanupChunkedDecoder(decoder);
          } else {
            // ignore: avoid_print
            print('FLAC decoder initialization failed - this may be expected');
          }
        } finally {
          malloc.free(filePathPtr);
        }
      } finally {
        malloc.free(dataPtr);
      }
    });

    test('should handle real OGG file processing', () async {
      if (!nativeLibAvailable) {
        // ignore: avoid_print
        print('Skipping OGG processing test - native library not available');
        return;
      }

      final oggPath = TestDataLoader.getAssetPath('sample_audio.ogg');
      final oggFile = File(oggPath);

      if (!await oggFile.exists()) {
        // Skip test if OGG file doesn't exist
        // ignore: avoid_print
        print('Skipping OGG test - file not found: $oggPath');
        return;
      }

      final fileBytes = await oggFile.readAsBytes();
      final dataPtr = malloc<ffi.Uint8>(fileBytes.length);
      final nativeData = dataPtr.asTypedList(fileBytes.length);
      nativeData.setAll(0, fileBytes);

      try {
        final detectedFormat = SonixNativeBindings.detectFormat(dataPtr, fileBytes.length);
        expect(detectedFormat, anyOf([SONIX_FORMAT_OGG, SONIX_FORMAT_UNKNOWN]));

        // Test chunked decoder initialization - use detected format or fallback to OGG
        final formatToUse = detectedFormat == SONIX_FORMAT_UNKNOWN ? SONIX_FORMAT_OGG : detectedFormat;
        final filePathPtr = oggFile.path.toNativeUtf8();
        try {
          final decoder = SonixNativeBindings.initChunkedDecoder(formatToUse, filePathPtr.cast<ffi.Char>());

          if (decoder.address != 0) {
            // Test seeking
            final seekResult = SonixNativeBindings.seekToTime(decoder, 0);
            expect(seekResult, anyOf([SONIX_OK, SONIX_ERROR_INVALID_DATA]));

            // Cleanup decoder
            SonixNativeBindings.cleanupChunkedDecoder(decoder);
          } else {
            // ignore: avoid_print
            print('OGG decoder initialization failed - this may be expected');
          }
        } finally {
          malloc.free(filePathPtr);
        }
      } finally {
        malloc.free(dataPtr);
      }
    });

    test('should handle unknown format detection', () async {
      if (!nativeLibAvailable) {
        // ignore: avoid_print
        print('Skipping unknown format test - native library not available');
        return;
      }

      final unknownPath = TestDataLoader.getAssetPath('invalid_format.xyz');
      final unknownFile = File(unknownPath);

      if (!await unknownFile.exists()) {
        // Skip test if unknown format file doesn't exist
        // ignore: avoid_print
        print('Skipping unknown format test - file not found: $unknownPath');
        return;
      }

      final fileBytes = await unknownFile.readAsBytes();
      if (fileBytes.isEmpty) {
        // Skip if file is empty
        return;
      }

      final dataPtr = malloc<ffi.Uint8>(fileBytes.length);
      final nativeData = dataPtr.asTypedList(fileBytes.length);
      nativeData.setAll(0, fileBytes);

      try {
        final detectedFormat = SonixNativeBindings.detectFormat(dataPtr, fileBytes.length);
        expect(detectedFormat, equals(SONIX_FORMAT_UNKNOWN));
      } finally {
        malloc.free(dataPtr);
      }
    });

    test('should handle edge cases in format detection', () async {
      if (!nativeLibAvailable) {
        // ignore: avoid_print
        print('Skipping edge cases test - native library not available');
        return;
      }

      // Test with empty file
      final emptyPath = TestDataLoader.getAssetPath('empty_file.mp3');
      final emptyFile = File(emptyPath);

      if (await emptyFile.exists()) {
        final fileBytes = await emptyFile.readAsBytes();
        if (fileBytes.isNotEmpty) {
          final dataPtr = malloc<ffi.Uint8>(fileBytes.length);
          final nativeData = dataPtr.asTypedList(fileBytes.length);
          nativeData.setAll(0, fileBytes);

          try {
            final detectedFormat = SonixNativeBindings.detectFormat(dataPtr, fileBytes.length);
            expect(detectedFormat, equals(SONIX_FORMAT_UNKNOWN));
          } finally {
            malloc.free(dataPtr);
          }
        }
      }

      // Test with null pointer
      final nullResult = SonixNativeBindings.detectFormat(ffi.Pointer<ffi.Uint8>.fromAddress(0), 0);
      expect(nullResult, equals(SONIX_FORMAT_UNKNOWN));

      // Test with empty buffer
      final emptyPtr = malloc<ffi.Uint8>(1); // Allocate at least 1 byte
      try {
        final emptyResult = SonixNativeBindings.detectFormat(emptyPtr, 0);
        expect(emptyResult, equals(SONIX_FORMAT_UNKNOWN));
      } finally {
        malloc.free(emptyPtr);
      }
    });

    test('should validate chunk size recommendations scale properly', () {
      if (!nativeLibAvailable) {
        // ignore: avoid_print
        print('Skipping chunk size test - native library not available');
        return;
      }

      final fileSizes = [
        1 * 1024 * 1024, // 1MB
        10 * 1024 * 1024, // 10MB
        100 * 1024 * 1024, // 100MB
        1000 * 1024 * 1024, // 1GB
      ];

      for (final format in [SONIX_FORMAT_MP3, SONIX_FORMAT_FLAC, SONIX_FORMAT_WAV, SONIX_FORMAT_OGG]) {
        int? previousChunkSize;

        for (final fileSize in fileSizes) {
          final chunkSize = SonixNativeBindings.getOptimalChunkSize(format, fileSize);

          // Chunk size should be reasonable
          expect(chunkSize, greaterThan(0));
          expect(chunkSize, lessThanOrEqualTo(10 * 1024 * 1024)); // Max 10MB

          // Chunk size should generally increase or stay the same with file size
          if (previousChunkSize != null) {
            expect(chunkSize, greaterThanOrEqualTo(previousChunkSize));
          }

          previousChunkSize = chunkSize;
        }
      }
    });

    test('should handle decoder cleanup safely', () {
      if (!nativeLibAvailable) {
        // ignore: avoid_print
        print('Skipping decoder cleanup test - native library not available');
        return;
      }

      // Test decoder cleanup with null pointer (should be safe)
      SonixNativeBindings.cleanupChunkedDecoder(ffi.Pointer<SonixChunkedDecoder>.fromAddress(0));

      // Test multiple cleanup calls should be safe
      final nullDecoder = ffi.Pointer<SonixChunkedDecoder>.fromAddress(0);
      SonixNativeBindings.cleanupChunkedDecoder(nullDecoder);
      SonixNativeBindings.cleanupChunkedDecoder(nullDecoder);

      // Test passes if we get here without crashing
      expect(true, isTrue);
    });

    test('should handle corrupted files gracefully', () async {
      if (!nativeLibAvailable) {
        // ignore: avoid_print
        print('Skipping corrupted files test - native library not available');
        return;
      }

      final corruptedPath = TestDataLoader.getAssetPath('corrupted_header.mp3');
      final corruptedFile = File(corruptedPath);

      if (!await corruptedFile.exists()) {
        // Skip test if corrupted file doesn't exist
        // ignore: avoid_print
        print('Skipping corrupted files test - file not found: $corruptedPath');
        return;
      }

      final fileBytes = await corruptedFile.readAsBytes();
      if (fileBytes.isEmpty) {
        return;
      }

      final dataPtr = malloc<ffi.Uint8>(fileBytes.length);
      final nativeData = dataPtr.asTypedList(fileBytes.length);
      nativeData.setAll(0, fileBytes);

      try {
        // Format detection should still work or return unknown
        final detectedFormat = SonixNativeBindings.detectFormat(dataPtr, fileBytes.length);
        expect(detectedFormat, anyOf([SONIX_FORMAT_MP3, SONIX_FORMAT_UNKNOWN]));

        // Test chunked decoder initialization with corrupted file
        final filePathPtr = corruptedFile.path.toNativeUtf8();
        try {
          final decoder = SonixNativeBindings.initChunkedDecoder(detectedFormat, filePathPtr.cast<ffi.Char>());

          if (decoder.address != 0) {
            // Processing should handle corruption gracefully
            final chunkPtr = malloc<SonixFileChunk>();
            final chunk = chunkPtr.ref;
            chunk.data = dataPtr;
            chunk.size = fileBytes.length;
            chunk.position = 0;
            chunk.is_last = 1;

            try {
              final result = SonixNativeBindings.processFileChunk(decoder, chunkPtr);

              if (result.address != 0) {
                final resultData = result.ref;
                // Should return an error for corrupted data
                expect(resultData.error_code, anyOf([SONIX_ERROR_INVALID_DATA, SONIX_ERROR_DECODE_FAILED, SONIX_ERROR_INVALID_FORMAT]));

                // Clean up result
                SonixNativeBindings.freeChunkResult(result);
              }
            } finally {
              malloc.free(chunkPtr);
            }

            // Cleanup decoder
            SonixNativeBindings.cleanupChunkedDecoder(decoder);
          } else {
            // ignore: avoid_print
            print('Corrupted file decoder initialization failed - this is expected');
          }
        } finally {
          malloc.free(filePathPtr);
        }
      } finally {
        malloc.free(dataPtr);
      }
    });
  });
}
