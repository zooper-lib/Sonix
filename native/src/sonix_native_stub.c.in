#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

// Sonix data structures (matching existing bindings)
typedef struct {
    float* samples;
    uint32_t sample_count;
    uint32_t sample_rate;
    uint32_t channels;
    uint32_t duration_ms;
} SonixAudioData;

typedef struct {
    uint8_t* data;
    size_t size;
    uint64_t position;
    int32_t is_last;
} SonixFileChunk;

typedef struct {
    float* samples;
    uint32_t sample_count;
    uint64_t start_sample;
    int32_t is_last;
} SonixAudioChunk;

typedef struct {
    SonixAudioChunk* chunks;
    uint32_t chunk_count;
    int32_t error_code;
    char* error_message;
} SonixChunkResult;

typedef struct {
    void* placeholder; // Opaque structure
} SonixChunkedDecoder;

// Format constants
#define SONIX_FORMAT_UNKNOWN 0
#define SONIX_FORMAT_MP3 1
#define SONIX_FORMAT_FLAC 2
#define SONIX_FORMAT_WAV 3
#define SONIX_FORMAT_OGG 4
#define SONIX_FORMAT_MP4 5

// Error codes
#define SONIX_OK 0
#define SONIX_ERROR_INVALID_FORMAT -1
#define SONIX_ERROR_DECODE_FAILED -2
#define SONIX_ERROR_OUT_OF_MEMORY -3
#define SONIX_ERROR_INVALID_DATA -4
#define SONIX_ERROR_FFMPEG_NOT_AVAILABLE -100

// Global error message
static char g_error_message[512] = "FFMPEG libraries not available. Please run setup script to build FFMPEG.";

// Stub implementations that return errors

int sonix_detect_format(const uint8_t* data, size_t size) {
    (void)data;
    (void)size;
    return SONIX_FORMAT_UNKNOWN;
}

SonixAudioData* sonix_decode_audio(const uint8_t* data, size_t size, int format) {
    (void)data;
    (void)size;
    (void)format;
    return NULL;
}

void sonix_free_audio_data(SonixAudioData* audio_data) {
    (void)audio_data;
}

char* sonix_get_error_message() {
    return g_error_message;
}

SonixChunkedDecoder* sonix_init_chunked_decoder(int format, const char* file_path) {
    (void)format;
    (void)file_path;
    return NULL;
}

SonixChunkResult* sonix_process_file_chunk(SonixChunkedDecoder* decoder, SonixFileChunk* file_chunk) {
    (void)decoder;
    (void)file_chunk;
    
    SonixChunkResult* result = (SonixChunkResult*)calloc(1, sizeof(SonixChunkResult));
    if (result) {
        result->error_code = SONIX_ERROR_FFMPEG_NOT_AVAILABLE;
        result->error_message = strdup(g_error_message);
    }
    return result;
}

int sonix_seek_to_time(SonixChunkedDecoder* decoder, uint32_t time_ms) {
    (void)decoder;
    (void)time_ms;
    return SONIX_ERROR_FFMPEG_NOT_AVAILABLE;
}

uint32_t sonix_get_optimal_chunk_size(int format, uint64_t file_size) {
    (void)format;
    (void)file_size;
    return 64 * 1024; // Default 64KB
}

void sonix_cleanup_chunked_decoder(SonixChunkedDecoder* decoder) {
    (void)decoder;
}

void sonix_free_chunk_result(SonixChunkResult* result) {
    if (result) {
        if (result->error_message) {
            free(result->error_message);
        }
        free(result);
    }
}