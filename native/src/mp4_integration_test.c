#include "sonix_native.h"
#include <stdio.h>
#include <assert.h>
#include <string.h>

// Test data - minimal valid MP4 file structure
static const uint8_t test_mp4_data[] = {
    // ftyp box
    0x00, 0x00, 0x00, 0x20,  // Box size (32 bytes)
    0x66, 0x74, 0x79, 0x70,  // Box type 'ftyp'
    0x69, 0x73, 0x6F, 0x6D,  // Major brand 'isom'
    0x00, 0x00, 0x02, 0x00,  // Minor version
    0x69, 0x73, 0x6F, 0x6D,  // Compatible brand 'isom'
    0x69, 0x73, 0x6F, 0x32,  // Compatible brand 'iso2'
    0x6D, 0x70, 0x34, 0x31,  // Compatible brand 'mp41'
    0x6D, 0x70, 0x34, 0x32,  // Compatible brand 'mp42'
    
    // Simplified moov box with audio track
    0x00, 0x00, 0x01, 0x00,  // Box size (256 bytes)
    0x6D, 0x6F, 0x6F, 0x76,  // Box type 'moov'
    
    // mvhd box (movie header)
    0x00, 0x00, 0x00, 0x6C,  // Box size (108 bytes)
    0x6D, 0x76, 0x68, 0x64,  // Box type 'mvhd'
    0x00, 0x00, 0x00, 0x00,  // Version 0, flags
    0x00, 0x00, 0x00, 0x00,  // Creation time
    0x00, 0x00, 0x00, 0x00,  // Modification time
    0x00, 0x00, 0x03, 0xE8,  // Timescale (1000)
    0x00, 0x00, 0x27, 0x10,  // Duration (10000)
    0x00, 0x01, 0x00, 0x00,  // Rate (1.0)
    0x01, 0x00, 0x00, 0x00,  // Volume (1.0), reserved
    0x00, 0x00, 0x00, 0x00,  // Reserved
    0x00, 0x00, 0x00, 0x00,  // Reserved
    0x00, 0x01, 0x00, 0x00,  // Matrix (identity)
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,  // Pre-defined
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x02,  // Next track ID
    
    // trak box (track)
    0x00, 0x00, 0x00, 0x80,  // Box size (128 bytes)
    0x74, 0x72, 0x61, 0x6B,  // Box type 'trak'
    
    // tkhd box (track header)
    0x00, 0x00, 0x00, 0x5C,  // Box size (92 bytes)
    0x74, 0x6B, 0x68, 0x64,  // Box type 'tkhd'
    0x00, 0x00, 0x00, 0x07,  // Version 0, flags (track enabled, in movie, in preview)
    0x00, 0x00, 0x00, 0x00,  // Creation time
    0x00, 0x00, 0x00, 0x00,  // Modification time
    0x00, 0x00, 0x00, 0x01,  // Track ID
    0x00, 0x00, 0x00, 0x00,  // Reserved
    0x00, 0x00, 0x27, 0x10,  // Duration
    0x00, 0x00, 0x00, 0x00,  // Reserved
    0x00, 0x00, 0x00, 0x00,  // Reserved
    0x00, 0x00, 0x00, 0x00,  // Layer, alternate group
    0x01, 0x00, 0x00, 0x00,  // Volume (1.0), reserved
    0x00, 0x01, 0x00, 0x00,  // Matrix (identity)
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,  // Width
    0x00, 0x00, 0x00, 0x00,  // Height
    
    // mdia box (media)
    0x00, 0x00, 0x00, 0x1C,  // Box size (28 bytes) - simplified
    0x6D, 0x64, 0x69, 0x61,  // Box type 'mdia'
    
    // mdhd box (media header)
    0x00, 0x00, 0x00, 0x18,  // Box size (24 bytes)
    0x6D, 0x64, 0x68, 0x64,  // Box type 'mdhd'
    0x00, 0x00, 0x00, 0x00,  // Version 0, flags
    0x00, 0x00, 0x00, 0x00,  // Creation time
    0x00, 0x00, 0x00, 0x00,  // Modification time
    0x00, 0x00, 0xAC, 0x44,  // Timescale (44100 Hz)
    0x00, 0x01, 0x5F, 0x90,  // Duration (90000 units)
    
    // Padding to reach the declared moov box size
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Invalid MP4 data (wrong signature)
static const uint8_t invalid_mp4_data[] = {
    0x00, 0x00, 0x00, 0x20,  // Box size
    0x6D, 0x6F, 0x6F, 0x76,  // Wrong type 'moov' instead of 'ftyp'
    0x69, 0x73, 0x6F, 0x6D,  // Data
    0x00, 0x00, 0x02, 0x00,
    0x69, 0x73, 0x6F, 0x6D,
    0x69, 0x73, 0x6F, 0x32,
    0x6D, 0x70, 0x34, 0x31,
    0x6D, 0x70, 0x34, 0x32
};

void test_mp4_format_detection() {
    printf("Testing MP4 format detection...\n");
    
    // Test valid MP4 detection
    int format = sonix_detect_format(test_mp4_data, sizeof(test_mp4_data));
    assert(format == SONIX_FORMAT_MP4);
    
    // Test invalid MP4 detection
    format = sonix_detect_format(invalid_mp4_data, sizeof(invalid_mp4_data));
    assert(format == SONIX_FORMAT_UNKNOWN);
    
    // Test with insufficient data
    format = sonix_detect_format(test_mp4_data, 4);
    assert(format == SONIX_FORMAT_UNKNOWN);
    
    printf("✓ MP4 format detection tests passed\n");
}

void test_mp4_decode_integration() {
    printf("Testing MP4 decode integration...\n");
    
    // Note: This test will fail because our test data doesn't have a complete
    // audio track structure, but it should fail gracefully with proper error handling
    SonixAudioData* result = sonix_decode_audio(test_mp4_data, sizeof(test_mp4_data), SONIX_FORMAT_MP4);
    
    // The decode should fail gracefully due to incomplete test data
    if (result == NULL) {
        const char* error = sonix_get_error_message();
        printf("Expected decode failure with error: %s\n", error);
        assert(error != NULL);
        assert(strlen(error) > 0);
    } else {
        // If it somehow succeeds, verify the structure
        assert(result->samples != NULL);
        assert(result->sample_count > 0);
        assert(result->sample_rate > 0);
        assert(result->channels > 0);
        sonix_free_audio_data(result);
    }
    
    // Test with invalid MP4 data
    result = sonix_decode_audio(invalid_mp4_data, sizeof(invalid_mp4_data), SONIX_FORMAT_MP4);
    assert(result == NULL);
    
    const char* error = sonix_get_error_message();
    assert(error != NULL);
    assert(strlen(error) > 0);
    
    printf("✓ MP4 decode integration tests passed\n");
}

void test_error_handling() {
    printf("Testing MP4 error handling...\n");
    
    // Test with NULL data
    SonixAudioData* result = sonix_decode_audio(NULL, 100, SONIX_FORMAT_MP4);
    assert(result == NULL);
    
    // Test with zero size
    result = sonix_decode_audio(test_mp4_data, 0, SONIX_FORMAT_MP4);
    assert(result == NULL);
    
    // Test with insufficient size
    result = sonix_decode_audio(test_mp4_data, 16, SONIX_FORMAT_MP4);
    assert(result == NULL);
    
    printf("✓ MP4 error handling tests passed\n");
}

int main() {
    printf("Running MP4 integration tests...\n\n");
    
    test_mp4_format_detection();
    test_mp4_decode_integration();
    test_error_handling();
    
    printf("\n✅ All MP4 integration tests completed!\n");
    return 0;
}